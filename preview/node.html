<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<h1 id="-node-js">第一章、初始node.js</h1>
<h2 id="1-node-js">1、什么是node.js</h2>
<p>Node.js® is a JavaScript runtime built on Chrome&#39;s V8 JavaScript engine.
Node.js 是一个基于 Chrome V8 引擎的 <strong>JavaScript 运行环境</strong>。</p>
<p>Node.js 的官网地址： <a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a></p>
<h2 id="2-node-js-javascript-">2、node.js中的Javascript运行环境</h2>
<p>注意：</p>
<ul>
<li>浏览器是 JavaScript 的前端运行环境。</li>
<li>Node.js 是 JavaScript 的后端运行环境。</li>
<li>Node.js 中<strong>无法调用 DOM 和 BOM 等浏览器内置 API</strong>。</li>
</ul>
<h2 id="3-node-js-">3、node.js可以做什么</h2>
<p>Node.js 作为一个 JavaScript 的运行环境，仅仅提供了基础的功能和 API。然而，基于 Node.js 提供的这些基础能，很多强大的工具和框架如雨后春笋，层出不穷，所以学会了 Node.js ，可以让前端程序员胜任更多的工作和岗位：
① 基于 Express 框架（<a href="http://www.expressjs.com.cn/），可以快速构建">http://www.expressjs.com.cn/），可以快速构建</a> Web 应用
② 基于 Electron 框架（<a href="https://electronjs.org/），可以构建跨平台的桌面应用">https://electronjs.org/），可以构建跨平台的桌面应用</a>
③ 基于 restify 框架（<a href="http://restify.com/），可以快速构建">http://restify.com/），可以快速构建</a> API 接口项目
④ 读写和操作数据库、创建实用的命令行工具辅助前端开发、etc…</p>
<h2 id="4-node-js-">4、查看已安装的Node.js版本号</h2>
<p>打开终端，在终端输入命令 <code>node –v</code> 后，按下回车键，即可查看已安装的 Node.js 的版本号。</p>
<p>Windows 系统快速打开终端的方式：
使用快捷键（<strong>Windows徽标键 + R</strong>）打开运行面板，输入 <strong>cmd</strong> 后直接回车，即可打开终端。</p>
<h2 id="5-">5、常见的终端快捷键</h2>
<ol>
<li>使用 ↑ 键，可以快速定位到上一次执行的命令</li>
<li>使用 tab 键，能够快速补全路径</li>
<li>使用 esc 键，能够快速清空当前已输入的命令</li>
<li>输入 cls 命令，可以清空终端</li>
</ol>
<h1 id="-fs-">第二章、fs文件系统模块</h1>
<h2 id="1-fs-">1、什么是fs文件系统模块</h2>
<p>fs 模块是 Node.js 官方提供的、用来操作文件的模块。它提供了一系列的方法和属性，用来满足用户对文件的操作需求。
例如：</p>
<ul>
<li><strong>fs.readFile()</strong> 方法，用来<strong>读取</strong>指定文件中的内容</li>
<li><strong>fs.writeFile()</strong> 方法，用来向指定的文件中<strong>写入</strong>内容</li>
</ul>
<p>如果要在 JavaScript 代码中，使用 fs 模块来操作文件，则需要使用如下的方式先导入它：</p>
<pre><code class="lang-js">const fs = require(&#39;fs&#39;)
</code></pre>
<h2 id="2-fs-readfile-">2、fs.readFile()</h2>
<h3 id="2-1-">2.1、语法</h3>
<pre><code class="lang-js">fs.readFile(path [,option] ,callback)
</code></pre>
<p>参数解读：</p>
<ul>
<li>参数1（path）：必选参数，字符串，表示文件的路径。</li>
<li>参数2（options）：可选参数，表示以什么<strong>编码格式</strong>来读取文件。</li>
<li>参数3（callback）：必选参数，文件读取完成后，通过回调函数拿到读取的结果。</li>
</ul>
<h3 id="2-2-">2.2、示例</h3>
<p>可以判断 err 对象是否为 null，从而知晓文件读取的结果：</p>
<pre><code class="lang-js">const fs = require(&#39;fs&#39;);
fs.readFile(&#39;1.txt&#39;,&quot;utf-8&quot;,function(err,datastr){
    if(err){
        return console.log(&quot;文件读取失败&quot;+err.message);
    }
    console.log(&#39;文件读取成功，内容是&#39;+datastr)
}
</code></pre>
<p>err如过文件读取成功，则返回null，如果读取失败，则返回一个错误对象</p>
<h2 id="3-fs-writefile-">3、fs.writeFile()</h2>
<h3 id="3-1-">3.1、语法</h3>
<pre><code>fs.writeFile(path ,data [,option] ,callback)
</code></pre><p>数解读：</p>
<ul>
<li>参数1（path）：必选参数，需要指定一个文件路径的字符串，表示文件的存放路径。</li>
<li>参数2（data）：必选参数，表示要写入的内容。</li>
<li>参数3（option）：可选参数，表示以什么格式写入文件内容，默认值是 utf8。</li>
<li>参数4（callback）：必选参数，文件写入完成后的回调函数。</li>
</ul>
<h2 id="3-2-">3.2、示例</h2>
<pre><code class="lang-js">fs.writeFile(&quot;1.txt&quot;,&quot;Hello Node.js&quot;,&quot;utf-8&quot;,function(err){
        if(err){
            return console.log(&quot;文件写入失败，原因是&quot;+err.message);
        }
        console.log(&quot;文件写入成功&quot;);
    })
</code></pre>
<h2 id="4-fs-">4、fs路径动态凭借的问题</h2>
<p>在使用 fs 模块操作文件时，如果提供的操作路径是以 ./ 或 ../ 开头的<strong>相对路径</strong>时，很容易出现路径动态拼接错误的问题。
原因：代码在运行的时候，<strong>会以执行 node 命令时所处的目录</strong>，动态拼接出被操作文件的完整路径。
解决方案：在使用 fs 模块操作文件时，<strong>直接提供完整的路径</strong>，不要提供 ./ 或 ../ 开头的相对路径，从而防止路径动态拼接的问题。</p>
<pre><code class="lang-js">//不要使用 ./ 或 ../ 这样的相对路劲
fs.read(&#39;./files/1.txt&#39;,&#39;utf-8&#39;,function(err.datastr){
    if(err) return console.log(&quot;读取文件失败&quot;+err.message)
    console.log(data.str)
})

// __dirname 表示执行js文件当前文件所处的目录
fs.readFile(__dirname,&#39;./files/1.txt&#39;,&#39;utf-8&#39;,function(err,datastr){
    if(err) return console.log(&quot;读取文件失败&quot;+err.message)
    console.log(data.str)
})
</code></pre>
<h2 id="5-">5、注意点</h2>
<ol>
<li>fs.writeFile() 方法只能用来创建文件，不能用来创建路径</li>
<li>重复调用 fs.writeFile() 写入同一个文件，新写入的内容会覆盖之前的旧内容</li>
</ol>
<h1 id="-path-">第三章、path路径模块</h1>
<h2 id="1-path-">1、什么是path路径模块</h2>
<p>path 模块是 Node.js 官方提供的、用来处理路径的模块。它提供了一系列的方法和属性，用来满足用户对路径的处理需求。
例如：</p>
<ul>
<li><p>path.join() 方法，用来将多<strong>个路径片段拼接成一个完整的路径字符串</strong></p>
</li>
<li><p>path.basename() 方法，用来从路径字符串中，将文件名解析出来</p>
<p>如果要在 JavaScript 代码中，使用 path 模块来处理路径，则需要使用如下的方式先导入它：</p>
</li>
</ul>
<pre><code class="lang-js">const path = require(&#39;path&#39;);
</code></pre>
<h2 id="2-path-join-">2、path.join()</h2>
<h3 id="2-1-">2.1、语法</h3>
<p>使用 path.join() 方法，可以把多个路径片段拼接为完整的路径字符串，语法格式如下：</p>
<pre><code class="lang-js">path.join([...paths])
</code></pre>
<p>参数解读：</p>
<ul>
<li>...paths <string> 路径片段的序列</li>
<li>返回值: <string></li>
</ul>
<h3 id="2-2-">2.2、示例</h3>
<p>使用 path.join() 方法，可以把多个路径片段拼接为完整的路径字符串：</p>
<pre><code class="lang-js">const pathStr = path.join(&#39;/a&#39;,&#39;/b/c&#39;,&#39;../&#39;,&#39;./d&#39;,&#39;e&#39;)
console.log(pathStr)   //输出\a\b\d\e

const pathstr2 = path.join(__dirname,&#39;./files/1.txt&#39;)
console.log(parhstr2)   //输出 当前文件所处目录\files\1.txt
</code></pre>
<h2 id="3-path-basename-">3、path.basename()</h2>
<h3 id="3-1-">3.1、语法</h3>
<p>使用 path.basename() 方法，可以获取路径中的最后一部分，经常通过这个方法获取路径中的文件名，语法格式如下：</p>
<pre><code class="lang-js">path.basename(path[,ext])
</code></pre>
<p>参数解读：</p>
<ul>
<li>path <string> 必选参数，表示一个路径的字符串</li>
<li>ext <string> 可选参数，表示文件扩展名</li>
<li>返回: <string> 表示路径中的最后一部分</li>
</ul>
<h3 id="3-2-">3.2、示例</h3>
<p>使用 path.basename() 方法，可以从一个文件路径中，获取到文件的名称部分：</p>
<pre><code class="lang-js">const fpath = &#39;a/b/c/index.html&#39;

var fullName = path.basename(fpath);
console.log(fullName);    //输出  index.html

var nameWithoutExt = pathname(fpath,&#39;.html&#39;)
console.log(nameWithoutExt)    //输出 index
</code></pre>
<h2 id="4-path-extname-">4、path.extname()</h2>
<h3 id="4-1-">4.1、语法</h3>
<p>使用 path.extname() 方法，可以获取路径中的扩展名部分，语法格式如下：</p>
<pre><code class="lang-js">path.extname(path)
</code></pre>
<p>参数解读：</p>
<ul>
<li>path <string>必选参数，表示一个路径的字符串</li>
<li>返回: <string> 返回得到的扩展名字符串</li>
</ul>
<h3 id="4-2-">4.2、示例</h3>
<p>使用 path.extname() 方法，可以获取路径中的扩展名部分：</p>
<pre><code class="lang-js">const fpath = &#39;a/b/c/index.html&#39;;

const fext = path.extname(fpath)
console.log(fext)   //输出 .html
</code></pre>
<h1 id="-http-">第四章、http模块</h1>
<h2 id="1-http-">1、什么是http模块</h2>
<p>http 模块是 Node.js 官方提供的、用来<strong>创建 web 服务器</strong>的模块。通过 http 模块提供的 http.createServer() 方法，就能方便的把一台普通的电脑，变成一台 Web 服务器，从而对外提供 Web 资源服务。</p>
<p>如果要希望使用 http 模块创建 Web 服务器，则需要先导入它：</p>
<pre><code class="lang-js">const http = require(&#39;http&#39;)
</code></pre>
<h2 id="2-http-">2、http模块的作用</h2>
<p>服务器和普通电脑的区别在于，服务器上安装了 <strong>web 服务器软件</strong>，例如：IIS、<strong>Apache</strong> 等。通过安装这些服务器软件，就能把一台普通的电脑变成一台 web 服务器。</p>
<p>在 Node.js 中，我们<strong>不需要使用</strong> IIS、Apache 等这些<strong>第三方 web 服务器软件</strong>。因为我们可以基于 Node.js 提供的 http 模块，<strong>通过几行简单的代码，就能轻松的手写一个服务器软件</strong>，从而对外提供 web 服务。</p>
<h2 id="3-">3、服务器相关的知识</h2>
<h3 id="3-1-ip-">3.1、IP地址</h3>
<p>IP 地址就是<strong>互联网上每台计算机的唯一地址</strong>，因此 IP 地址具有唯一性。如果把“个人电脑”比作“一台电话”，那么“IP地址”就相当于“电话号码”，只有在知道对方 IP 地址的前提下，才能与对应的电脑之间进行数据通信。
IP 地址的格式：通常用“<strong>点分十进制</strong>”表示成（a.b.c.d）的形式，其中，a,b,c,d 都是 0~255 之间的十进制整数。例如：用点分十进表示的 IP地址（192.168.1.1）
<strong>注意</strong>：</p>
<ol>
<li><strong>互联网中每台 Web 服务器，都有自己的 IP 地址</strong>，例如：大家可以在 Windows 的终端中运行 ping <a href="http://www.baidu.com">www.baidu.com</a> 命令，即可查看到百度服务器的 IP 地址。</li>
<li>在开发期间，自己的电脑既是一台服务器，也是一个客户端，为了方便测试，可以在自己的浏览器中输入 127.0.0.1 这个 IP 地址，就能把自己的电脑当做一台服务器进行访问了。</li>
</ol>
<h3 id="3-2-">3.2、域名和域名服务器</h3>
<p>尽管 IP 地址能够唯一地标记网络上的计算机，但IP地址是一长串数字，不直观，而且不便于记忆，于是人们又发明了另一套<strong>字符型的地址方案</strong>，即所谓的<strong>域名（Domain Name）地址。</strong>
IP地址和域名是一一<strong>对应的关系</strong>，这份对应关系存放在一种叫做<strong>域名服务器</strong>(DNS，Domain name server)的电脑中。使用者只需通过好记的域名访问对应的服务器即可，对应的转换工作由域名服务器实现。因此，<strong>域名服务器就是提供 IP 地址和域名之间的转换服务的服务器。</strong></p>
<p>注意：</p>
<ol>
<li>单纯使用 IP 地址，互联网中的电脑也能够正常工作。但是有了域名的加持，能让互联网的世界变得更加方便。</li>
<li>在开发测试期间， <strong>127.0.0.1 对应的域名是 localhost</strong>，它们都代表我们自己的这台电脑，在使用效果上没有任何区别。</li>
</ol>
<h3 id="3-3-">3.3、端口号</h3>
<p>计算机中的端口号，就好像是现实生活中的门牌号一样。通过门牌号，外卖小哥可以在整栋大楼众多的房间中，准确把外卖送到你的手中。
同样的道理，在一台电脑中，可以运行成百上千个 web 服务。每个 web 服务都对应一个唯一的端口号。客户端发送过来的网络请求，通过端口号，可以被准确地交给<strong>对应的 web 服务</strong>进行处理。</p>
<p><img src="C:\Users\lsy\AppData\Roaming\Typora\typora-user-images\image-20230304143909710.png" alt="image-20230304143909710"></p>
<p>注意：</p>
<ol>
<li>每个端口号不能同时被多个 web 服务占用。</li>
<li>在实际应用中，URL 中的 <strong>80 端口可以被省略</strong>。</li>
</ol>
<h2 id="4-web-">4、创建web服务器的基本步骤</h2>
<h3 id="4-1-">4.1、基本步骤</h3>
<ol>
<li>导入 http 模块</li>
<li>创建 web 服务器实例</li>
<li>为服务器实例绑定 request 事件，监听客户端的请求</li>
<li>启动服务器</li>
</ol>
<h4 id="4-1-1-http-">4.1.1、导入http模板</h4>
<p>如果希望在自己的电脑上创建一个 web 服务器，从而对外提供 web 服务，则需要导入 http 模块：</p>
<pre><code class="lang-js">const http = require(&#39;http&#39;);
</code></pre>
<h4 id="4-1-2-web-">4.1.2、创建web服务器实例</h4>
<p>调用 ==http.createServer()== 方法，即可快速创建一个 web 服务器实例：</p>
<pre><code class="lang-js">const server = http.createServer()
</code></pre>
<h4 id="4-1-3-request-">4.1.3、为服务器绑定request事件</h4>
<p>为服务器实例绑定 request 事件，即可监听客户端发送过来的网络请求：</p>
<pre><code class="lang-js">server.on(&#39;request&#39;, (req, res) =&gt; {
    console.log(&#39;Someone visit web server&#39;)
}）
</code></pre>
<h4 id="4-1-4-">4.1.4、启动服务器</h4>
<p>调用服务器实例的 .listen() 方法，即可启动当前的 web 服务器实例：</p>
<pre><code class="lang-js">server.listen(8080, () =&gt; {
  console.log(&#39;server running at http://127.0.0.1:8080&#39;)
})
</code></pre>
<h3 id="4-2-req-">4.2、req请求对象</h3>
<p>只要服务器接收到了客户端的请求，就会调用通过 <strong>server.on()</strong> 为服务器绑定的 <strong>request 事件处理函数</strong>。
如果想在事件处理函数中，<strong>访问与客户端相关的数据或属性</strong>，可以使用如下的方式：</p>
<pre><code class="lang-js">server.on(&#39;request&#39;, (req) =&gt; {
    // req 是请求对象，包含了与客户端相关的数据和属性
  // req.url 是客户端请求的 URL 地址
  const url = req.url
  // req.method 是客户端请求的 method 类型
  const method = req.method
  const str = `Your request url is ${url}, and request method is ${method}`
  console.log(str)

}）
</code></pre>
<p>==注意：浏览器只能发起默认的get请求==</p>
<h3 id="4-3-res-">4.3、res响应对象</h3>
<p>在服务器的 request 事件处理函数中，如果想访问与<strong>服务器相关的数据或属性</strong>，可以使用如下的方式：</p>
<pre><code class="lang-js">/ res 是响应端对象，包含了与服务端相关的数据和属性
server.on(&#39;request&#39;, (req, res) =&gt; {
  //要发送客户端的字符串
  const str = `Your request url is ${url}, and request method is ${method}`
  console.log(str)
  // 调用 res.end() 方法，向客户端响应一些内容，并结束这次请求的处理过程
  res.end(str)
})
</code></pre>
<h3 id="4-4-">4.4、解决中文乱码问题</h3>
<p>当调用 res.end() 方法，向客户端发送中文内容的时候，会出现乱码问题，此时，需要<strong>手动设置内容的编码格式</strong>：</p>
<pre><code class="lang-js">server.on(&#39;request&#39;, (req, res) =&gt; {
  // 定义一个字符串，包含中文的内容
  const str = `您请求的 URL 地址是 ${req.url}，请求的 method 类型为 ${req.method}`
  // 调用 res.setHeader() 方法，设置 Content-Type 响应头，解决中文乱码的问题
  res.setHeader(&#39;Content-Type&#39;, &#39;text/html; charset=utf-8&#39;)
  // res.end() 将内容响应给客户端
  res.end(str)
})
</code></pre>
<h3 id="4-5-url-html-">4.5、根据不同的url响应不同的html内容</h3>
<pre><code class="lang-js">const http = require(&#39;http&#39;)
const server = http.createServer()

server.on(&#39;request&#39;, (req, res) =&gt; {
  // 1. 获取请求的 url 地址
  const url = req.url
  // 2. 设置默认的响应内容为 404 Not found
  let content = &#39;&lt;h1&gt;404 Not found!&lt;/h1&gt;&#39;
  // 3. 判断用户请求的是否为 / 或 /index.html 首页
  // 4. 判断用户请求的是否为 /about.html 关于页面
  if (url === &#39;/&#39; || url === &#39;/index.html&#39;) {
    content = &#39;&lt;h1&gt;首页&lt;/h1&gt;&#39;
  } else if (url === &#39;/about.html&#39;) {
    content = &#39;&lt;h1&gt;关于页面&lt;/h1&gt;&#39;
  }
  // 5. 设置 Content-Type 响应头，防止中文乱码
  res.setHeader(&#39;Content-Type&#39;, &#39;text/html; charset=utf-8&#39;)
  // 6. 使用 res.end() 把内容响应给客户端
  res.end(content)
})

server.listen(80, () =&gt; {
  console.log(&#39;server running at http://127.0.0.1&#39;)
})
</code></pre>
<p><img src="C:\Users\lsy\AppData\Roaming\Typora\typora-user-images\image-20230304145447819.png" alt="image-20230304145447819"></p>
<h1 id="-">第五章、模块化</h1>
<h2 id="1-">1、什么是模块化</h2>
<p><strong>模块化</strong>是指解决一个复杂问题时，自顶向下逐层<strong>把系统划分成若干模块的过程</strong>。对于整个系统来说，模块是可组合、分解和更换的单元。</p>
<h3 id="-">编程领域的模块化</h3>
<p>编程领域中的模块化，就是<strong>遵守固定的规则</strong>，把一个大文件拆成独立并互相依赖的多个小模块。</p>
<p>把代码进行模块化拆分的好处：</p>
<p>① 提高了代码的复用性</p>
<p>② 提高了代码的可维护性</p>
<p>③ 可以实现按需加载</p>
<h2 id="2-">2、模块化规范</h2>
<p><strong>模块化规范</strong>就是对代码进行模块化的拆分与组合时，需要遵守的那些规则。</p>
<p>例如：</p>
<ul>
<li>使用什么样的语法格式来引用模块</li>
<li>在模块中使用什么样的语法格式向外暴露成员</li>
</ul>
<p><strong>模块化规范的好处</strong>：大家都遵守同样的模块化规范写代码，降低了沟通的成本，极大方便了各个模块之间的相互调用，利人利己。</p>
<h2 id="3-node-js-">3、Node.js中模块化</h2>
<h3 id="3-1-">3.1、分类</h3>
<p>Node.js 中根据模块来源的不同，将模块分为了 3 大类，分别是：</p>
<ul>
<li><p>==内置模块==（内置模块是由 Node.js 官方提供的，例如 fs、path、http 等）</p>
</li>
<li><p>==自定义模块==（用户创建的每个 .js 文件，都是自定义模块）</p>
</li>
<li>==第三方模块==（由第三方开发出来的模块，并非官方提供的内置模块，也不是用户创建的自定义模块，使用前需要先下载）</li>
</ul>
<h3 id="3-2-">3.2、加载模块</h3>
<p>使用强大的 ==require()== 方法，可以加载需要的<strong>内置模块、用户自定义模块、第三方模块进行使用</strong>。例如：</p>
<pre><code class="lang-js">//加载内置模块的fs模块
const fs = require(&#39;fs&#39;);

//加载用户的自定义模块
const custom = require(&#39;./custom.js&#39;);

//加载第三方模块
const monent = require(&#39;moment&#39;);
</code></pre>
<p>注意：</p>
<ul>
<li>在使用require加载用户自定义模块可以省略   .js   的后缀名。</li>
<li>使用 require() 方法加载其它模块时，会执行被加载模块中的代码。</li>
</ul>
<h3 id="3-3-">3.3、模块作用域</h3>
<h4 id="3-3-1-">3.3.1、什么是模块作用域</h4>
<p>和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做<strong>模块作用域</strong>。</p>
<p><img src="C:\Users\lsy\AppData\Roaming\Typora\typora-user-images\image-20230307134825924.png" alt="image-20230307134825924"></p>
<h4 id="3-3-2-">3.3.2、好处</h4>
<p>防止了全局变量污染的问题</p>
<p><img src="C:\Users\lsy\AppData\Roaming\Typora\typora-user-images\image-20230307134921725.png" alt="image-20230307134921725"></p>
<h3 id="3-4-">3.4、向外共享模块作用域中的成员</h3>
<h4 id="3-4-1-module-">3.4.1、module对象</h4>
<p>在每个 .js 自定义模块中都有一个 module 对象，它里面<strong>存储了和当前模块有关的信息</strong>，打印如下：</p>
<p><img src="C:\Users\lsy\AppData\Roaming\Typora\typora-user-images\image-20230307140415061.png" alt="image-20230307140415061"></p>
<h4 id="3-4-2-module-exports-">3.4.2、module.exports对象</h4>
<p>在自定义模块中，可以使用 module.exports 对象，将模块内的成员共享出去，供外界使用。</p>
<p>外界用 <strong>require()</strong> 方法导入自定义模块时，得到的就是 module.exports 所指向的对象。</p>
<h4 id="3-4-3-">3.4.3、共享成员时的注意点</h4>
<p>使用 require() 方法导入模块时，导入的结果，<strong>永远以 module.exports 指向的对象为准</strong>。</p>
<p><img src="C:\Users\lsy\AppData\Roaming\Typora\typora-user-images\image-20230307140820914.png" alt="image-20230307140820914"></p>
<h4 id="3-4-4-exports-">3.4.4、exports对象</h4>
<p>由于 module.exports 单词写起来比较复杂，为了简化向外共享成员的代码，Node 提供了 exports 对象。默认情况下，==exports 和 module.exports 指向同一个对象==。最终共享的结果，还是以 module.exports 指向的对象为准。</p>
<h4 id="3-4-5-exports-module-exports-">3.4.5、exports和module.exports的使用误区</h4>
<p>时刻谨记，require() 模块时，==得到的永远是 module.exports 指向的对象==：</p>
<p><img src="C:\Users\lsy\AppData\Roaming\Typora\typora-user-images\image-20230307141225461.png" alt="image-20230307141225461"></p>
<p><strong>注意：</strong>为了防止混乱，建议大家不要在同一个模块中同时使用 exports 和 module.exports</p>
<h3 id="3-5-node-js-">3.5、Node.js中的模块化规范</h3>
<p>Node.js 遵循了 CommonJS 模块化规范，CommonJS 规定了<strong>模块的特性和各模块之间如何相互依赖</strong>。</p>
<p>CommonJS 规定：</p>
<p>① 每个模块内部，<strong>module 变量</strong>代表当前模块。</p>
<p>② module 变量是一个对象，它的 exports 属性（即 <strong>module.exports）是对外的接口</strong>。</p>
<p>③ 加载某个模块，其实是加载该模块的 module.exports 属性。<strong>require() 方法用于加载模块。</strong></p>
<h1 id="-npm-">第六章、npm与包</h1>
<h2 id="1-">1、包</h2>
<h3 id="1-1-">1.1、什么是包</h3>
<p>Node.js 中的$\textcolor{red}{第三方模块}$又叫做包。</p>
<p>就像电脑和计算机指的是相同的东西，第三方模块和包指的是同一个概念，只不过叫法不同。</p>
<h3 id="1-2-">1.2、下载包的网址</h3>
<p>国外有一家 IT 公司，叫做 <strong>npm, Inc.</strong> 这家公司旗下有一个非常著名的网站： <a href="https://www.npmjs.com/">https://www.npmjs.com/</a> ，它是<strong>全球最大的包共享平台</strong>，你可以从这个网站上搜索到任何你需要的包，只要你有足够的耐心！</p>
<p>到目前位置，全球约 1100 多万的开发人员，通过这个包共享平台，开发并共享了超过 120 多万个包 供我们使用。</p>
<p><strong>npm, Inc. 公司</strong>提供了一个地址为 <a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a> 的服务器，来对外共享所有的包，我们可以从这个服务器上下载自己所需要的包。</p>
<p><strong>注意：</strong></p>
<ul>
<li>从 <a href="https://www.npmjs.com/">https://www.npmjs.com/</a> 网站上搜索自己所需要的包</li>
<li>从 <a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a> 服务器上下载自己需要的包</li>
</ul>
<h3 id="1-3-">1.3、如何下载包</h3>
<p><strong>npm, Inc. 公司</strong>提供了一个包管理工具，我们可以使用这个包管理工具，从 <a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a> 服务器把需要</p>
<p>的包下载到本地使用。</p>
<p>这个包管理工具的名字叫做 Node Package Manager（简称 npm 包管理工具），这个包管理工具随着 Node.js 的安</p>
<p>装包一起被安装到了用户的电脑上。</p>
<p>大家可以在终端中执行$\textcolor{red}{npm -v}$ 命令，来查看自己电脑上所安装的 npm 包管理工具的版本号：</p>
<h2 id="2-npm-">2、npm初体验</h2>
<h3 id="2-1-">2.1、示例：格式化时间</h3>
<p>$\textcolor{red}{① 使用 npm 包管理工具，在项目中安装格式化时间的包 moment}$</p>
<p>② 使用 require() 导入格式化时间的包</p>
<p>③ 参考 moment 的官方 API 文档对时间进行格式化</p>
<h3 id="2-2-">2.2、在项目中安装包</h3>
<p>如果想在项目中安装指定名称的包，需要运行如下的命令：</p>
<pre><code>npm install 包的完整名臣
</code></pre><p>上述的装包命令，可以简写成如下格式：</p>
<pre><code>npm i 包的完整名称
</code></pre><h3 id="2-3-">2.3、初次安装包哪些文件</h3>
<p>初次装包完成后，在项目文件夹下多一个叫做 $\textcolor{red}{node_modules}$的文件夹和 $\textcolor{red}{package-lock.json}$ 的配置文件。</p>
<p>其中：</p>
<p>$\textcolor{blue}{node_modules}$ 文件夹用来$\textcolor{red}{存放所有已安装到项目中的包}$。require() 导入第三方包时，就是从这个目录中查找并加载包。</p>
<p>$\textcolor{blue}{package-lock.json}$ 配置文件用来$\textcolor{red}{记录 node_modules 目录下的每一个包的下载信息}$，例如包的名字、版本号、下载地址等。</p>
<p>注意：程序员不要手动修改 node_modules 或 package-lock.json 文件中的任何代码，npm 包管理工具会自动维护它们</p>
<h3 id="2-4-">2.4、安装指定版本</h3>
<p>默认情况下，使用 npm install 命令安装包的时候，会自动安装最新版本的包。如果需要安装指定版本的包，可以在包名之后，通过 <strong>@ 符号</strong>指定具体的版本，例如：</p>
<pre><code>npm i moment@2.22.2
</code></pre><h3 id="2-5-">2.5、报的语义化版本规范</h3>
<p>包的版本号是以“点分十进制”形式进行定义的，总共有三位数字，例如 <strong>2.24.0</strong></p>
<p>其中每一位数字所代表的的含义如下：</p>
<p>第1位数字：大版本</p>
<p>第2位数字：功能版本</p>
<p>第3位数字：Bug修复版本</p>
<p><strong>版本号提升的规则</strong>：只要前面的版本号增长了，则后面的版本号归零。</p>
<h2 id="3-">3、包管理配置文件</h2>
<p>npm 规定，在项目根目录中，<strong>必须</strong>提供一个叫做 package.json 的包管理配置文件。用来记录与项目有关的一些配置</p>
<p>信息。例如：</p>
<ul>
<li>项目的名称、版本号、描述等</li>
<li>项目中都用到了哪些包</li>
<li>哪些包只在开发期间会用到</li>
<li>那些包在开发和部署时都需要用到</li>
</ul>
<h3 id="3-1-">3.1、多人协作问题</h3>
<p>现实问题：整个项目的体积是 30.4M；第三方包的体积是 28.8M；项目源代码的体积 1.6M</p>
<p>遇到的问题：<strong>第三方包的体积过大</strong>，不</p>
<p>方便团队成员之间共享项目源代码。</p>
<p>解决方案：$\textcolor{red}{共享时剔除node_modules}$</p>
<h3 id="3-2-">3.2、如何记录项目安装了哪些包</h3>
<p>在<strong>项目根目录</strong>中，创建一个叫做 <strong>package.json</strong> 的配置文件，即可用来记录项目中安装了哪些包。从而方便剔除</p>
<p>node_modules 目录之后，在团队成员之间共享项目的源代码。</p>
<p><strong>注意</strong>：今后在项目开发中，一定要把 node_modules 文件夹，<strong>添加到 .gitignore 忽略文件中。</strong></p>
<h3 id="3-3-package-json">3.3、快速创建package.json</h3>
<p>npm 包管理工具提供了一个快捷命令，可以在<strong>执行命令时所处的目录中</strong>，快速创建 package.json 这个包管理配置文件：</p>
<pre><code class="lang-js">//作用：在执行命令所处的目录中，快速创建package.json文件
npm init -y
</code></pre>
<p>注意：</p>
<p>① 上述命令$\textcolor{red}{只能在英文的目录下成功运行}$！所以，项目文件夹的名称一定要使用英文命名，$\textcolor{red}{不要使用中文，不能出现空格}$。</p>
<p>② 运行 npm install 命令安装包的时候，npm 包管理工具会自动把包的名称和版本号，记录到 package.json 中。</p>
<h3 id="3-4-dependcies-">3.4、dependcies节点</h3>
<p>package.json 文件中，有一个 dependencies 节点，专门用来记录您使用 <strong>npm install 命令</strong>安装了哪些包。</p>
<p><img src="C:\Users\lsy\AppData\Roaming\Typora\typora-user-images\image-20230307215145806.png" alt="image-20230307215145806"></p>
<h3 id="3-5-">3.5、一次性安装所有的包</h3>
<p>可以运行 <strong>npm install 命令（或 npm i）</strong>一次性安装所有的依赖包：</p>
<pre><code class="lang-js">//执行npm install 命令时，npm包管理工具先读取package,json 中华的dependencies节点
//读取到记录的所有依赖包和版本号之后，npm 包管理工具智慧，npm包管理工具把这些包一次性下载到项目中
npm install
</code></pre>
<h3 id="3-6-">3.6、卸载包</h3>
<p>可以运行 <strong>npm uninstall</strong> 命令，来卸载指定的包</p>
<pre><code class="lang-js">npm uninstall moment
</code></pre>
<p>注意：npm uninstall 命令执行成功后，会把卸载的包，自动从 package.json 的 dependencies 中移除掉。</p>
<h3 id="3-7-devdependencies-">3.7、 <strong>devDependencies 节点</strong></h3>
<p>如果某些包<strong>只在项目开发阶段</strong>会用到，在<strong>项目上线之后不会用到</strong>，则建议把这些包记录到 devDependencies 节点中。</p>
<p>与之对应的，如果某些包在开发和项目上线之后都需要用到，则建议把这些包记录到 dependencies 节点中。</p>
<p>您可以使用如下的命令，将包记录到 devDependencies 节点中：</p>
<pre><code class="lang-js">//安装指定的包，并记录到deDependencies节点中
npm i 包名 -D
//注意：上述命令是简写形式，等价于下面的完整写法
npm install 包名 -save-dev
</code></pre>
<h2 id="4-">4、解决下包速度慢的问题</h2>
<h3 id="4-1-">4.1、下包速度慢的原因</h3>
<p>在使用 npm 下包的时候，默认从国外的 <a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a> 服务器进行下载，此时，网络数据的传输需要经过漫长的海底光缆，因此下包速度会很慢。</p>
<h3 id="4-2-">4.2、解决问题</h3>
<p>淘宝在国内搭建了一个服务器，专门把国外官方服务器上</p>
<p>的包<strong>同步</strong>到国内的服务器，然后在国内提供下包的服务。</p>
<p>从而极大的提高了下包的速度。</p>
<p>扩展：</p>
<p><strong>镜像</strong>（Mirroring）是一种文件存储形式，一个磁盘上的</p>
<p>数据在另一个磁盘上存在一个完全相同的副本即为镜像。</p>
<p><img src="C:\Users\lsy\AppData\Roaming\Typora\typora-user-images\image-20230307220015486.png" alt="image-20230307220015486"></p>
<h3 id="4-3-npm-">4.3、切换npm的下包镜像源</h3>
<p>下包的镜像源，指的就是<strong>下包的服务器地址</strong></p>
<pre><code>#查看当前的下包镜像源
npm config get registry
#将下包的镜像源切换到淘宝镜像源
npm config set registry=https://registry.npm.taobao.org/
#检查镜像源是否下载成功
npm config get registry
</code></pre><h3 id="4-4-nrm">4.4、nrm</h3>
<p>为了更方便的切换下包的镜像源，我们可以安装 <strong>nrm</strong> 这个小工具，利用 nrm 提供的终端命令，可以快速查看和切换下包的镜像源。</p>
<pre><code>#通过npm 包管理器，将nrm安装为全局可用的工具
npm i nrm -g
#查看所有可用的镜像源
nrm ls
#将下包的镜像源切换到taobao镜像
nrm use taobao
</code></pre><h2 id="5-">5、包的分类</h2>
<p>使用 npm 包管理工具下载的包，共分为两大类，分别是：</p>
<ul>
<li>项目包</li>
<li>全局包</li>
</ul>
<h3 id="5-1-">5.1、项目包</h3>
<p>那些被安装到项目的 node_modules 目录中的包，都是项目包。</p>
<p>项目包又分为两类，分别是：</p>
<ul>
<li><strong>开发依赖包</strong>（被记录到 devDependencies 节点中的包，只在开发期间会用到）</li>
<li><strong>核心依赖包</strong>（被记录到 dependencies 节点中的包，在开发期间和项目上线之后都会用到）</li>
</ul>
<p><img src="C:\Users\lsy\AppData\Roaming\Typora\typora-user-images\image-20230307220742333.png" alt="image-20230307220742333"></p>
<h3 id="5-2-">5.2、全局包</h3>
<p>在执行 npm install 命令时，如果提供了 <strong>-g</strong> 参数，则会把包安装为<strong>全局包。</strong></p>
<p>全局包会被安装到 <strong>C:\Users\用户目录\AppData\Roaming\npm\node_modules</strong> 目录下。</p>
<pre><code>npm i 包名 -g      #全局安装指定的包
npm uninstall 包名 -g   #卸载全局安装的包
</code></pre><p>注意：</p>
<p>① 只有<strong>工具性质的包</strong>，才有全局安装的必要性。因为它们提供了好用的终端命令。</p>
<p>② 判断某个包是否需要全局安装后才能使用，可以参考官方提供的使用说明即可</p>
<h3 id="5-3-i5ting_toc">5.3、i5ting_toc</h3>
<p>i5ting_toc 是一个可以把 md 文档转为 html 页面的小工具，使用步骤如下:</p>
<p><img src="C:\Users\lsy\AppData\Roaming\Typora\typora-user-images\image-20230307221158905.png" alt="image-20230307221158905"></p>
<h3 id="5-4-">5.4、规范的包结构</h3>
<p>在清楚了包的概念、以及如何下载和使用包之后，接下来，我们深入了解一下<strong>包的内部结构</strong>。</p>
<p>一个规范的包，它的组成结构，必须符合以下 3 点要求：</p>
<p>① 包必须以<strong>单独的目录</strong>而存在</p>
<p>② 包的顶级目录下要必须包含 <strong>package.json</strong> 这个包管理配置文件</p>
<p>③ package.json 中必须包含 <strong>name，version，main</strong> 这三个属性，分别代表包的名字、版本号、包的入口。</p>
<p>注意：以上 3 点要求是一个规范的包结构必须遵守的格式，关于更多的约束，可以参考如下网址：</p>
<p><a href="https://yarnpkg.com/zh-Hans/docs/package-json">https://yarnpkg.com/zh-Hans/docs/package-json</a></p>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>