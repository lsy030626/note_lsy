# 第一阶段、初级阶段

## 一、数据的类型、数据的输入和输出

### ① 数据类型-常量-变量

#### 1、数据类型

<img src="C:\Users\lsy\AppData\Roaming\Typora\typora-user-images\image-20230314164101002.png" alt="image-20230314164101002" style="zoom:50%;" />

**关键词**



![image-20230314164825861](C:\Users\lsy\AppData\Roaming\Typora\typora-user-images\image-20230314164825861.png)

#### 2、常量

常量是指在程序运行过程中，其值不发生改变的量。常量又可以分为$\textcolor{blue}{整型、实型（也称浮点型）、字符型、字符串型}$。

<img src="C:\Users\lsy\AppData\Roaming\Typora\typora-user-images\image-20230314172453686.png" alt="image-20230314172453686" style="zoom:50%;" />

#### 3、变量

变量代表内存中具有特定属性的一个存储单元，它用来存放数据，即变量的值。**这些值在程序的执行过程中是可以改变的**。

变量名实际上以一个名字代表一个对应的存储单元地址。编译，链接程序是，有编译系统为**每个变量名分配对应的内存地址（就是空间）**，从变量中取值实际上是通过变量名找到内存中存储单元的位置，并从该存储单元中读取数据。

**变量命名规则**

+ 只能由字母、数字和下画线三种字符组成
+ 第一个字符必须为字母或下画线
+ 注意，变量名不能与关键字同名!
+ 尽量做到"见名知意"

#### 4、整型数据

##### 4.1、符号常量

定义一个整型变量时要使用关键字int。我们来看下面的例子。

```c
#inchude <stdio.h>
#define PI 3+2

int main（）
{
	int i=PI*2;
	printf("i=%d\n",i);
}
```

最终的输出结果是7,原因是符号常量PI是直接替换的效果，因此不可以写PI=8.

##### 4.2、整型变量

初级只需掌握`int i = 10`;==变量i是4个字节==

#### 5、浮点型数据

##### 5.1、浮点型常量

表示浮点型常量的形式有两种，如下表所示，其中e代表10的幂次，幂次可正可负。

**表示浮点型常量的两种形式**

| 形式     | 示例                     |
| -------- | ------------------------ |
| 小数形式 | 0.123                    |
| 指数形式 | 3e-3(为3*10^3^ ,即0.003) |

注意：字母e(或E)之前必须有数字，且==e后面的指数必须为整数==。

正确示例：le3、1.8e-3、-123e-6、-.1e-3.

错误示例：e3、2.1e3.5,e3,e.

##### 5.2、浮点型变量

通过`float f`来定义浮点变量，f占用4个字节的空间

#### 6、字符型数据

##### 6.1、字符型常量

用单引号括起来的一个字符是字符型常量，且只能包含一个字符!例如，'a'、'A'。1、是正确的字符型常量**（双引号的是字符串常量）**

**转义字符：**

| 转义字符 | 作用   |
| -------- | ------ |
| \n       | 换行   |
| \b       | 退格   |
| \\\\     | 反斜杠 |

##### 6.2、存储形式

字符型变量使用关键字char进行定义，==一个字符型变量占用1字节大小的空间==。一个字符常量存放到一个字符型变量中时，实际上并不是把该字符的字型放到内存中，而是把该字符的ASCⅡ码值放到存储单元中

```
#include <stdio.h>
int main(){
	char c='A';
	printf("%c\n",c+32);
	printf("%d\n",c)
}

//输出 a  65
```

#### 7、字符串型常量

​	字符串型常量是由一对双引号括起来的字符序列.例如，"How do you do."、"CHINA",“a“和“$123.45”是合法的字符串型常量。**但要注意的是，'a'是字符型常量，而“a“是字符串型常量，二者是不同的**。

​	C语言规定，在每个字符串型常量的结尾加一个字符申结束标志，以便系统据此判断字符串是否结束。**C语言规定以字符'\0'作为字符串结束标志。**

​	例如，字符串型常量“CHINA”在内存中的存储结果如下图所示，它占用的内存单元不是5个字符，而是6个字符，即大小为6字节。最后一个字符为‘\0’,然而，在输出时不输出’\0‘,因为‘\0’无法显示

![image-20230314185442759](C:\Users\lsy\AppData\Roaming\Typora\typora-user-images\image-20230314185442759.png)

### ② 混合运算，printf

#### 1、混合运算

类型强制转换情景

整型数进行除法运算时，如果运算结果为小数，那么存储浮点数时一定要进行强制类型转换，请看下面例子

```c
int main()
{
	int i=5;
	float j=i/2;
	float k=(float)i/2;
	printf("%f\n",j);	//输出2.000000
	printf("%f\n",k);   //输出2.500000
	return 0;
}
```

j得到的值为2,k得到的值是2.5,因为当我们整数做除法时，默认进行整除，要得到小数，需要首先进行强制类型转换操作。

#### 2、printf函数介绍

printf函数可以输出各种类型的数据，包括整型、浮点型、字符型、字符串型等，实际原理是printf函数将**这些类型的数据格式化为字符串后**，放入标准输出缓冲区，然后将结果显示到屏幕上。

**基本语法**

```
#include <studio.h>
int printf(const char *format,...)
```

printf函数根据format给出的格式打印输出到stdout(标准输出)和其他参数中。

字符串格式(format)由两部分组成：显示到屏幕上的字符和定义printf函数显示的其他参数。我们可以指定一个包含文本在内的format字符串，也可以是映射到printf的其他参数的“特殊”字符。例如：

```c
int age = 21;
printf("Hello %s,you are %d years old\n","Bob",age)

//输出Hello Bob,you are 21 years old
```

其中，%s表示在该位置插入首个参数(一个字符串),%d示第二个参数(一个整数)应该放在哪里。不同的%codes表示不同的变量类型，也可以限制变量的长度，printf函数的具体代码格式如下表所示.

| 代码 | 格式                         |
| ---- | ---------------------------- |
| %c   | 字符                         |
| %d   | 带符号整数                   |
| %f   | 浮点数                       |
| %s   | 一串字符                     |
| %u   | 无符号整数                   |
| %0   | 无符号八进制数               |
| %x   | 无符号十六进制数，用小写字母 |
| %X   | 无符号十六进制数，用大写字母 |
| %p   | 一个指针                     |
| %%   | 一个’%‘符号                  |

位于%格式化命令之间的一个整数被称为最小字段宽度说明符，通常会加上空格来控制格式。

+ 用%f精度修饰符指定想要的小数位数，例如，%5.2f会至少显示5位数字并带有2位小数的浮点数.
+ 用%s精度修饰符简单地表示一个最大的长度，以补充句点前的最小字段长度。

==printf函数的所有输出都是右对齐的==，除非在%号后放置了负号，例如，%-5.2f会显示5位字符、2位小数位的浮点数并且左对齐。

```c
#include <stdio.h>
int main()
{
	int i=10;
	float f=96.3;
	printf("student number="%3d" score="%5.2f\n"，i,f);
	printf("student number="%-3d" score="%5.2f\n",i,f);
	printf("%10s\n","hello");
}
```

<img src="C:\Users\lsy\AppData\Roaming\Typora\typora-user-images\image-20230314191436428.png" alt="image-20230314191436428" style="zoom: 67%;" />

### ③ 整型进制转换

计算机中只能存储二进制数，即0和1,而在对应的物理硬件上则是高、低电平.为了更方便地观察内存中的**二进制数**情况，除我们正常使用的**十进制数外，计算机还提供了十六进制数和八进制数**。

#### 1、二进制

首先.在计算机中，1字节为8位，1位即二进制的1位，它存储0或1。int型常量的大小为4字节，即32位。

设有二进制数0100 1100 0011 0001 0101 0110 1111 1110，其最低位是2的零次方，代表数值的最高位是2的30次方**，最高位为符号位，符号位为1时是补码**，将在高级阶段的补码部分讲解。

#### 2、八进制

上面的二进制数对应的八进制数是011414253376,它以0开头标示，数位的变化范围是0~7。

二进数转换为八进制数的方式是，**对应的二进制数每3位转换为1位八进制数**.

首先将上面的二进制数按每3位隔开，得到01 001 100 001 100 010 101 011 011 111 110,然后每3位对应0~7范围内的数进行对应转挽，得到八进制数011414253376.由于实际编程时，**识别八进制数时前面需要加0**.所以在前面加了一个0。

#### 3、十六进制

上面的二进制数对应的十六进制数是0x4C3156FE,它以**0x开头**标示，数位的变化范围是**0～9和A~F,其中A代表10.F代表15**,对应的二进制数每4位转换为1位十六进制数，十六进制在观察内存时需要频繁使用。

#### 4、十进制

上面的二进制数对应的十进制数是1278301950，具体计算需要**以2的幂次相加**依次来计算是2^1^+2^2^+2^3^+…+2^30^来实现(为1的位置就需要2的幂次，为零不需要),最好通过计算器来进行。

#### 5、CPU数据存储

目前我们执行到语句int i=123,变量i会在内存上被分配空间，大小为4字节，会看到如下图所示，其中i的值变为7b(我们以十六进制方式查看内存),其十进制值为7×16+11=123.i的值是0x0000007b。为什么显示结果为7b 000000呢?原因是英特尔的**CPU采用了小端方式进行数据存储，因此低位在前、高位在后。**

![image-20230320223359122](C:\Users\lsy\AppData\Roaming\Typora\typora-user-images\image-20230320223359122.png)

#### 6、八进制转十进制

八进制数0173转换为十进制数的方式是1×8^2^+7×8^1^+3×8^0^=123.

<img src="C:\Users\lsy\AppData\Roaming\Typora\typora-user-images\image-20230320223847185.png" alt="image-20230320223847185" style="zoom: 80%;" />

#### 7、十进制转二进制

方法是让123不断地除以2,并把余数写在右边，把商写在下方，直到商为0.然后逆序写出所有余数，即可得到转换后的二进制数1111011,详细过程如下图所示。

![image-20230320224214746](C:\Users\lsy\AppData\Roaming\Typora\typora-user-images\image-20230320224214746.png)

#### 8、十进制转十六进制

十进制数转换为十六进制数的方式是除以16，。对应的十六进制数为7b

#### 9、十进制转八进制

十进制数转换为八进制数的方式是除以8。

#### 10、解不出来，就全部转化为二进制在进行转换

#### 11、小技巧

手动转换一个数的进制后，若不知道转换后的进制数是否正确，则可在Windows操作系统下选择“开始”→“计算器”,打开“计算器”,然后选择菜单项“查看”→“程序员”得到如下图所示的计算器。输入一个十进制数后，单击“十六进制”“八进制”或“二进制”,即可得到对应进制的转换结果。

<img src="C:\Users\lsy\AppData\Roaming\Typora\typora-user-images\image-20230320224833451.png" alt="image-20230320224833451" style="zoom:67%;" />

### ④ scanf标准输入

#### 1、scanf函数的原理

C语言未提供输入/输出关键字，其输入和输出是通过标准函数库来实现的。C语言通过**scanf函数**读取键盘输入，键盘输入又被称为**标准输入**，当scanf函数读取标准输入时，如果还没有输入任何内容，那么scanf函数会被卡住(专业用语为**阻塞)**。

```c
#include <stdio.h>
//scanf %d%f现里边有\n空格，忽略
//scanf 不忽略内容
int main()
{
	int i=10
    char c;
	scanf("%d",&i);//注意一定要取地址
	printf("%d\n",i);
    //fflush(stdin)://清空标准输入缓冲区
    scanf("?,&c);
	printf("c=?n",c);
	return 0;
}
//scanf其实输入的是字符串，通过%d等将字符串转化为对应类型
//定义变量时，如果没有给其赋值，那定义变量的语句是不执行的，因为编译器给对应变量分好了地址
```

**注意：**

执行时输入20.然后回车，显示结果如下图所示.为什么第二个scanf函数不会被阻塞呢?其实是因为**第二个scanf函数读取了缓冲区中的'\n'**,即scanf("c",&c)实现了读取，打印其实输出了换行，所以不会阻塞.

<img src="C:\Users\lsy\AppData\Roaming\Typora\typora-user-images\image-20230321103750537.png" alt="image-20230321103750537" style="zoom:67%;" />

但是如果我们将上面例子中注释的**flush(stdin)打开**，就会发现第二个scanf("%d",&c)会阻塞。

行缓冲：在这种情况下，当在输入和输出中遇到换行符时，将执行真正的LO处理操作，这时，我们输入的字符先存放到缓冲区中，等按下回车键换行时才进行实际的IO操作。典型代表是**标准输入缓冲区(stdin)和标准输出缓冲区(stdout)**,printf使用的是stdout。

如上面的例子所示，我们**向标准输入缓冲区中放入的字符为"20\n'**,输入\n1(回车)后，scanf函数才开始匹配，scanf函数中的%d配整型数20,然后放入变量i中，接着进行打印输出，**这时\n'仍然在标准输入缓冲区(stdin)内**，如果第二个scanf函数为scanf("%d",&i),那么依然会发生阻塞，**因为scanf函数在读取整型数、浮点数，字符串(**后面介绍数组时讲解字符串)时，会**忽略‘\n'(回车符）**、空格符等字符(忽略是指scanf函数执行时会首先删除这些字符，然后再阻塞).scanf函数匹配一个字符时，会在缓冲区删除对应的字符，因为在执行scanf("%c",&c)语句时，不会忽略任何字符，所以scanf("%c",&c)读取了还在缓冲区中残留的'\n'。

#### 2、多种数据类型混合输入

当我们让scanf函数一次读取多种类型的数据时，对于字符型数据要格外小心，**因为当一行数据中存在字符型数据读取时，读取的字符并不会忽略空格和'\n'(回车符)**,所以使用方法如下例所示。编写代码时，我们需要在%d和%c之间加入一个空格。输入格式和输出效果如下图所示，scanf函数匹配成功了4个成员，所以返回值为4,我们可以通过返回值来判断scanf函数匹配成功了几个成员，**中间任何有一个成员匹配出错，后面的成员都会匹配出错**。

```c
#include <stdio.h>
int main()
{
	int i,ret;
	char C;
	float f:
	ret=scanf("%d %c%f",&i,&c,&f);//要在之前加个空格
	printf("i=%d,c=%c,f=5.2f\n",i,c,f);
	return 0;
}
```

<img src="C:\Users\lsy\AppData\Roaming\Typora\typora-user-images\image-20230321105253477.png" alt="image-20230321105253477" style="zoom:67%;" />

## 二、运算符和表达式

### ① 运算符

C 语言提供了 13 种类型的运算符，如下所示。

**（1）算术运算符（+ - * / %）。**

**（2）关系运算符（> < ==  >=  <=  !=）。**

**（3）逻辑运算符（! && ||）。**

（4）位运算符（<< >> ~ | ^ &）。

​	**(5) 赋值运算符(=及其扩展赋值运算符)**

​	(6)条件运算符(？：)

​	(7)逗号运算符(，)

​	(8)指针运算符(*和&)    --讲指针时讲解

​	**(9)求字节数运算符(sizeof)**

​	**(10)强制类型转换运算符(（类型）)**

​	(11)分量运算符(.->)。--讲结构体时讲解

​	(12)下标运算符([])。---讲数组时讲解

​	(13)其他（如函数调用运算符0）。---讲函数时讲解

### ② 运算符优先级表

![image-20230405134518772](C:\Users\lsy\AppData\Roaming\Typora\typora-user-images\image-20230405134518772.png)

![image-20230405134531766](C:\Users\lsy\AppData\Roaming\Typora\typora-user-images\image-20230405134531766.png)

说明：
同一优先级的运算符，运算次序由结合方向所决定。
简单记就是：！>算术运算符>关系运算符>&&〉川>赋值运算符

### ③ 求字节运算符sizeof

实际sizeof是一个运算符(不是函数)，不像其他运算符是一个符号，sizeof是字母组成的，用于求常量或变量所占用的空间大小，请看下例：

```c
#include <stdio.h>

int main()
int i=0;
printf("i size is %d\n",sizeof(i));
return 0;
```

运行结果为i size is 4,可以求得整型变量占用的空间大小是4个字节

## 三、数组

### 1、定义

一维数组的定义格式为

> 类型说明符 数组名 [常量表达式];    int a[10];

声明数组需要遵循规则：

+ 数组名的命名规则和变量名的相同，即遵循标识符命名规则.
+ 在定义数组时，需要指定数组中元素的个数，方括号中的常量表达式用来表示元素的个数，即数组长度。
+ 常量表达式中可以包含常量和符号常量，但不能包含变量。也就是说，C语言不允许对数组的大小做动态定义，即数组的大小不依赖于程序运行过程中变量的值.

例如：以下是错误的声明示例（最新的 C 标准支持，但是最好不要这么写）

```c
int n;
scanf("%d",&n);/*在程序中临时输入数组的大小*/
int a[n];
```

### 2、一维数组在内存中的存储

![image-20230405135847668](C:\Users\lsy\AppData\Roaming\Typora\typora-user-images\image-20230405135847668.png)

**一维数组的初始化**

（1）在定义数组时对数组元素赋初值。例如，

> int a[10]={0,1,2,3,4,5,6,7,8,9};
>
> 不能写成：
>
> int a[10];a[10]={0,1,2,3,4,5,6,7,8,9}

（2）可以只给一部分元素赋值。例如

> int a[10]={0,1,2,3,4};

定义 a 数组有 10 个元素，但花括号内只提供 5 个初值，**这表示只给前** **5** **个元素赋初值，后 5 个元素的值为0。**

（3）如果要使一个数组中全部元素的值为 0，那么可以写为

> int a[10]={0,0,0,0,0,0,0,0,0,0};
>
> 或者：
>
> int a[10]={0}

（4）在对全部数组元素赋初值时，由于数据的个数已经确定，因此可以不指定数组的长度。

> int a[]={1,2,3,4,5};

### 3、数组的访问越界

> 与java等其他语言不同，其他语言会自动报错，但c不会

```c
int main()
{
int a[5]={1,2,3,4,5};/定义数组时，数组长度必须固定
int j=20;
int i=10;
a[5]=6;/越界访问
a[6]=7;/越界访问会造成数据异常
printf("i=%dn",i);//i发生改变
return 0;
}
```

下图显示了代码运行情况。如下图所示，在第 10 行左键打上断点，然后单击“小虫子”按钮，在内存视图依次输入&j、&a、&i 来查看整型变量 j、整型数组 a、整型变量 i 的地址，即可看到三个变量的地址，这里就像我们给衣柜的每个格子的编号，第一格、第二格……一直到柜子的最后一格。**操作系统对内存中的每个位置也给予一个编号**，对于 Windows 32 位控制台应用程序来说，这个编号的范围是从 0x00 00 00 00 到 0xFF FF FF FF，总计为 2 的 32 次方，大小为4G。这些编号称为地址（我们是 64 位程序，地址显示的是 64 位）

![image-20230405155749480](C:\Users\lsy\AppData\Roaming\Typora\typora-user-images\image-20230405155749480.png)

在变量窗口中输入sizeof(a)，可以看到数组a的大小为20字节，计算方法其实就是sizeof(int)*5：数组中有 5 个整型元素，每个元素的大小为 4 字节，所以共有 20 字节。访问元素的顺序是依次从a[0]到 a[4]，a[5]=6、a[6]=7 均为访问越界。下图显示了代码运行情况，从中看出，执行到第 12行时，变量 i 的值被修改了，这就是**访问越界的危险性——未对变量 i 赋值，其值却发生了改变！数组另一个值得关注的地方是，编译器并不检查程序对数组下标的引用是否在数组的合法范围内。**

### 4、数组的传递

```c
#include <stdio.h>
//一维数组的传递数组长度无法传递给子函数
//C语言的函数调用方式是值传递
//数组名传递给子函数后，子函数的形参接收到的是数组的起始地址。因此不能不能使用sizeof(a)/size(int)来获取数组的长度
vold print(int b[],int len)
{
	int i;
	for(i=0;i<len;i++)
	printf("%3d",b[i]);
	b[4]=20;//在子函数中修改数组元素
	printf("\n");
数组越界
//一维数组的传递
#define N 5
int main()
{
    //获取数组长度，不调用函数，可以写为
    //sizeof(a)/sizeof(int)即得到数组的长度
	int a[5]={1,2,3,4,5};//定义数组时，数组长度必须固定
	print(a,5);
	printf(("a[4]=%dn",a[4]);/a[4]发生改变
	return 0;
}
```

如下图 1 所示，在第 21 行点击向下箭头，进入 print 函数，这时会发现数组 b 的大小变为8 字节,**这是因为一维数组在传递时，其长度是传递不过去的，所以我们通过 len来传递数组中的元素个数**。实际数组名中存储的是数组的首地址，在调用函数传递时，是将数组的首地址给了变量 b（其实变量 b 是指针类型，具体原理会在指针节讲解），在 b[]的方括号中填写任何数字都是没有意义的。这时我们在 print 函数内修改元素 b[4]=20，可以看到数组 b 的起始地址和 main 函数中数组 a 的起始地址相同，即二者在内存中位于同一位置，当函数执行结束时，数组 a 中的元素 a[4]就得到了修改。

### 5、字符数组初始化及传递

字符数组的定义方法与前面介绍的一维数组类似。例如，

> char c[10];

字符数组的初始化可以采用以下方式。

（1）对每个字符单独赋值进行初始化。例如，

> c[0]='I';c[1]='';c[2]='a';c[3]='m';c[4]='';c[5]='h';c[6]='a';c[7]='p';c[8]='p';c[9]='y';

（2）对整个数组进行初始化。例如，

> char c[10]={'I','a','m','h','a','p','p','y'}

但工作中一般不用以上两种初始化方式，因为字符数组一般用来存取字符串。通常采用的初始化方式是 **char c[10]= "hello"**。因为 C 语言规定字符串的结束标志为'\0'，而系统会对字符串**常量自动加一个'\0'**，为了保证处理方法一致，一般会人为地在字符数组中添加'\0'，所以字符数组存储的字符串长度必须比字符数组少 1 字节。例如，**char c[10]最长存储 9 个字符，剩余的 1个字符用来存储'\0.**

```c
#include <stdlo.h>
vold print(char c[]){
	int i=0;
	while(c[i])
	{
		printf("%c",c[i]);
		i++;
	}
    printf("\n");
}
/字符数组存储字符串，必须存储结束符0'
int main()
{
	char c[5]={'h','e","l','l','o'};
	char d[5]="how";
	printf("%s\n",c);/会发现打印了乱码
	printf("%s\n",d);
	print(d);
	return 0;
}
```

上例中代码的执行结果如下图所示。为什么对数组赋值"hello"却打印出乱码，这是因为printf 通过%s 打印字符串时，原理是依次输出每个字符，当读到结束符'\0'时，结束打印；

<img src="C:\Users\lsy\AppData\Roaming\Typora\typora-user-images\image-20230405161403089.png" alt="image-20230405161403089" style="zoom:50%;" />

**我们通过** **print** **函数模拟实现** **printf 的%s打印效果**，当 c[i]为'\0'时，其值是 0，循环结束，也可以写为 c[i]!='\0'

### 6、scanf读取字符串

```c
#include <stdio.h>
int main()
{
	char c[10];
	char d[10];
	scanf("%s",c);
	printf("%s\n",c);
	scanf("%s%s",c,d);
	printf("c=%s,d=%s\n",c,d);
	return 0;
}
```

scanf 通过%s 读取字符串，对 c 和 d 分别输入"are"和"you"（中间加一个空格），**scanf在使用%s读取字符串时，会忽略空格和回车（这一点与%d和%f 类似）。**

<img src="C:\Users\lsy\AppData\Roaming\Typora\typora-user-images\image-20230405161658945.png" alt="image-20230405161658945" style="zoom:50%;" />

### 7、gets函数与puts函数

gets 函数类似于 scanf 函数，用于读取标准输入。前面我们已经知道 scanf 函数在读取字符串时遇到空格就认为读取结束，所以当输入的字符串存在空格时，我们需要使用 gets 函数进行读取。gets 函数的格式如下：

> char *gets(char *str)

gets 函数从 STDIN（标准输入）读取字符并把它们加载到 str（字符串）中，**直到遇到换行符（\n）**。如下例所示，执行后，我们输入"how are you"，共 11 个字符，可以看到 gets 会读取空格，同时可以看到我们并未给数组进行初始化赋值，但是最后有'\0'，这是因为 gets 遇到\n 后，不会存储\n，而是将其翻译为空字符'\0'。

puts 函数类似于 printf 函数，用于输出标准输出。puts 函数的格式如下

> int puts(char *str);

函数 puts 把 str（字符串）写入 STDOU（标准输出）。puts 会将数组 c 中存储的"how are you"字符串打印到屏幕上，同时打印换行，相对于 printf 函数，puts 只能用于输出字符串，同时多打印一个换行符，等**价于 printf(“%s\n”,c)。**

### 8、str系列字符串操作函数

| 函数                                           | 说明                                                   |
| ---------------------------------------------- | ------------------------------------------------------ |
| size_t strlen(char *str);                      | 求字符串长度                                           |
| char *strcpy(char *to, const char *from);      | 用于将某个字符串复制到字符串数组中                     |
| int strcmp(const char *str1, const char *str2) | 用于比较两个字（str1等于str2返回1，大于返回1，小于-1） |
| char *strcat(char *str1, const char *str2）    | 用于将两个字符串连接到一起                             |

对于传参类型 char*，直接放入字符数组的数组名即可。

## 四、指针

### 1、指针的定义

内存区域中的每字节都对应一个编号，这个编号就是“地址”。如果在程序中定义了之个变量，那么在对程序进行编译时，系统就会给这个变量分配内存单元。**按变量地址存取变量值的方式称为“直接访问”，如printf("%d",i);、scanf("%d",&i);等**；另一种存取变量值的方式称为“间接访问”，即将变量ⅰ的地址存放到另一个变量中。在C语言中，指针变量是一种特殊的变量，
它用来存放变量地址。

指针变量的定义格式：

> 基类型 *指针变量名     例如   int *i_pointer

指针与指针变量是两个概念，一个变量的地址称为该变量的“指针”.例如，地址2000是变量i的指针。如果有一个变量专门用来存放另一变量的地址（即指针），那么称它为“指针变量”。本章中编写的程序都是64位应用程序，寻址范围为64位即8字节，所以对于本章来说**sizeof(i_pointer)=**8。如果**编写的程序是32位，那么寻址范围就是4字节**（考研中往往会强调程序是32位的程序）

### 2、取地址符与取值操作符，指针本质

取地址**操作符为&，也称引用**，通过该操作符我们可以获取一个变量的地址值；取值操作符为`*`，也称解引用，通过该操作符我们可以得到一个地址对应的数据。如下例所示，我们**通过&获取整型变量ⅰ的地址值**，然后对整型指针变量p进行初始化，p中存储的是整型变量ⅰ的地址值，所以通过`*` p(printf函数中的*p)就可以获取整型变量i的值。p中存储的是一个绝对地址值，那为什么取值时会获取4字节大小的空间呢？这是因为p为整型变量指针，每个it型数据占用4字节大小的空间，所以p在解引用时会访问4字节大小的空间，同时以整型值对内存进行解析。

```c
#include <stdio.h>
int main(){
	int i=5;
	int *p = &i;
	print("i%d\n",i);
	print("*p%d\n",*p);
	return 0;
}
```

**注意事项：**

1. 指针变量前面的“*”，表示该变量为指针型变量。例如，

   > float *pointer_1;

2. 在定义指针变量时必须指定其类型。需要注意的是，只有整型变量的地址才能放到指向整型变量的指针变量中。例如，下面的赋值是错误的：

   > float a;
   > int pointer_1;
   > pointer_.1=&a;//毫无意义而且会出错，有兴趣的读者可以自行尝试 

3. &*pointer_1含义：优先级相同，因此从右自左方向结合，因此含义与&a相同，都表示a的地址，也就是pointer_1。

4. *&a含义：都表示变量a的值，也就是变量a.

5. (4)C语言本质上是一种自由形式的语言，这很容易诱使我们把“`*`”写在靠近类型的一侧如`int *a`这个声明与前面一个声明具有相同的意思，而且看上去更清晰，a被声明成类型为`int*`的指针。但是，这并不是一个好习惯，因为类似`int *a,b,c`的语句会使人们很自然地认为这条语句把所有三个变量声明为指向整型的指针，但事实上并非如此，“`*`”实际上是*a的一部分，只对标识符起作用，但其余两个变量只是普通的整型变量.要声明三个指针变量，正确的语句
   如下：

   `int *a,*b,*c`

### 3、指针的传递

```c
#include <stdio.h>
void change(intj）
{
	j=5;
}
int main(
	int i=10;
	printf("before change i=%dn",i;)//这里打断点
	change(i);/在这一步按下箭头，进入change函数
	printf("after change i=%d\n",i);
	return 0;
}
```

**变量1的地址是0x61fe1c**.按向下键（或F7)进入change函数，这时变量j的值的确为10，但是**&j的值为0x61fdf0**,也就是j和i的地址并不相同.运行j=5后，**change函数实际修改的是地址0x61fdf0上的值**，从10变成了5，接着change函数执行结束，变量i的值肯定不会发生改变，因为变量ⅰ的地址是0x61fe1c而非0x61fdf0

**原理**

我么需要关注的是栈空间的变化。当main函数开始执行时，系统会为main函数开辟函数栈空间，当程序走到int i时，main函数的栈空间就会为变量i分配4字节大小的空间。调用change函数时，系统会为change函数重新分配新的函数栈空间，并为形参变量j分配4字节大小的空间.在调用change(i)时，实际上是将i的值赋值给j,我们把这种效果称为值传递(**C语言的函数调用均为值传递**)，因此，当我们在change函数的函数栈空间内修改变量j的值后，change函数执行结束，其栈空间就会释放，j就不再存在，ⅰ的值不会改变。

![image-20230405204726479](C:\Users\lsy\AppData\Roaming\Typora\typora-user-images\image-20230405204726479.png)

解决办法：将地址作为值传递过去，通过地址去改变量的值

```c
#include <stdio.h>
void change(int*j)
{
	*j=5;/间接访问得到变量i
}
	/指针的传递
int main{
	int i=10;
	printf("before change i=%d\n",i);
	change(&i);/传递变量i的地址
	printf("after change i=%d n",i);
	return 0;
}
```

### 4、指针的偏移

前面介绍了指针的传递。指针即地址，就像我们找到了一栋楼，这栋楼的楼号是B,那么往前就是A,往后就是C,所以应用指针的**另一个场景就是对其进行加减**，但对指针进行乘除是没有意义的，就像家庭地址乘以5没有意义那样。在工作中，我们把对指针的加减称为指针的偏移，加就是向后偏移，减就是向前偏移。下面我们来看例11.

```i
#include <stdio.h>
#define N5
//指针的偏移
int main()
{
	int a[N]=1,2,3,4,5}:
	int *p;
	int i;
	p=a;
	//保证等号两边的数值类型一致
	for(i=0;i<Ni++)/正序输出
	{
		printf("%3d",*(p+i));
	}
	printf("\n-----n");
	p=&a[4};//让p指向最后一个元素
	for(i=0;i<N;i++){	//逆序输出
	printf("%3d",*(p-i));
	printf("\n");
	return 0;
}
```

如下图所示，数组名中存储着数组的起始地址Ox61fd0,其类型为整型指针，所以可以将其赋值给整型指针变量p,可以从监视窗口中看到p+1的值为0x61ff4。那么为什么加1后不是0x61fdf1呢？因为指针变量加1后，偏**移的长度是其基类型的长度，也就是偏移sizeof(int),**这样通过*(p+1)就可以得到元素a[1]。编译器在编译时，数组取下标的操作正是转换为指针偏移来完成

#### 4.1、指针与一维数组

为什么一维数组在函数调用进行传递时，它的长度子函数无法知道呢？这是由于**一维数组名中存储的是数组的首地址**.如下例所示，数组名c中存储是一个起始地址（这里最好结合本小节视频来学习，才能理解更加清晰)，所以子函数change中其实传入了一个地址。定义一个
指针变量时，指针变量的类型要和数组的数据类型保持一致，通过取值操作，就可将“”改为“H”,这种方法称为指针法。获取数组元素时，也可以通过取下标的方式来获取数组元素并进行修改，这种方法称为下标法

```c
//数组名作为实参传递给子函数时，是弱化为指针的
//练习传递与偏移
void change(char *d)
{	
	*d=H;
	d[1]='E';
	*(d+2)=‘L’;
}
int main(){
	char c[10]"hello";
	change(c);
	puts(c);
	return 0;
}
```

### 5、指针与动态内存申请

很多读者在学习C语言的数组后都会觉得数组长度固定很不方便，其实C语言的数组长度固定是因为**其定义的整型、浮点型、字符型变量**、数组变都在栈空间中，而栈空间的大小在编译时是确定的。如果使用的空间大小不确定，那么就要使用堆空间。请看下面例子

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int main()
{
	int i;
	char *p;	
	scanf(("%d",&i);//输入要申请的空间大小
	p=(char*)malloc(i);//使用malloc动态申请堆空间
	strcpy(p,"malloc success");
	puts(p);
	free(p;//free时必须使用malloc申请时返回的指针值，不能进行任何偏移
	printf("free success\n");
	return 0;
}
```

首先我们来看malloc函数.在执行`#include<stdlib.h>void *malloc(size_t size;`时，需要给malloc传递的参数是一个整型变量，因为这里的size_t即为int;返回值为`void*`类型的指针，`void*`类型的指针只能用来存储一个地址而不能进行偏移，因为malloc并不知道我们申请的
空间用来存放什么类型的数据，所以**确定要用来存储什么类型的数据后，都会将`void*`强制转换为对应的类型。，所以将其强制转换为char*类型**

**同时需要注意指针本身大小，和其指向的空间大小，是两码事，不能和前面的变量类比去理解！**

![image-20230405211213981](C:\Users\lsy\AppData\Roaming\Typora\typora-user-images\image-20230405211213981.png)

既然都是内存空间，为什么还要分栈空间和堆空间呢？栈是计算机系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈操作、出栈操作都有专门的指令执行，这就决定了栈的效率比较高；堆则是C/C+函数库提供的数据结构，它的机制很复杂，例如为了分配一块内存，库函数会按照一定的算法（具体的算法请参考关于数据结构、操作系统的书籍)在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能由于内存碎片太多)，那么就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后返回.显然，**堆的效率要比栈低得多**。（这段了解即可）
栈空间由系统自动管理，而堆空间的申请和释放需要自行管理，所以在具体例子中需要通过free函数释放堆空间。free函数的头文件及格式为

```c
#include<studio.h>
void free(void *ptr)
```

### 6、栈空间和对空间的差异

```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
/函数栈空间释放后，函数内的所有局部变量消失
char* print_stack()
{
	char c[17]="I am print_stack";
	puts(c);
	return c;
}
//堆空间不会因函数执行结束而释放
char* print_malloc()
{
	char *p;
	p=(char*)malloc(20);
	strcpy(p,"I am print_malloc");
	puts(p):
	return p;
}
int main()
{
	char *p;
	p=print_stack();/数据放在栈空间
	printf("p=%s\n",p);
	p=print_malloc();/数据放在堆空间
	puts(p);
	return 0;
}
```

为什么第二次打印会有异常？原因是print_stack()
函数中的字符串存放在栈空间中，函数执行结束后，栈空间会被释放，字符数组C的原有空间已被分配给其他函数使用，因此在调用print_.stack()函数后，printf("p=%s\n",p）中的p不能获取栈空间的数据。而print_malloc()函数中的字符串存放在堆空间中，堆空间只有在执行free操作后才会释放，否则在进程执行过程中会一直有效。

**函数main等放在栈内存中，当函数执行完成，就销毁内存，而malloc申请的空间存放在堆内存中，堆内存只有在程序执行完成释放或者主动用`free()`释放。**

## 五、函数

### 1、函数的声明与定义

函数间的调用关系是，**由主函数调用其他函数**，其他函数也可以互相调用。同一个函数可人被一个或多个函数调用任意次

```c
func.h
#include <stdio.h>
#include <stdlib.h>
int printstar(inti);/函数声明
void print_message();


func.c
#include "func.h"
int printstar(inti)/i即为形式参数
{
	printf("**-------------------**\n"）;
	printf("printstar %d\n",i);
	return i+3;
}
void print_message()/可以调用printstar
{
	printf("how do you do\n");
	printstar(3);
}
           
main.c
#include "func.h"
int main(){
	int a=10;
	a=printstar(a);
	print_message();
	printstar(a);
	return 0;           
}           
```

**c语言的编译和执行特点**

1. 一个C程序由一个或多个程序模块组成，每个程序模块作为一个源程序文件.对于较大的程序，**通常将程序内容分别放在若干源文件中，再由若干源程序文件组成一个C程序**。这样处理便于分别编写、分别编译，进而提高调试效率、（复试有用）。一个源程序文件可以为多个C程序共用。
2. c语言的执行是从main函数开始的。

**函数声明和定义的差别：**

1. 函数的定义是指对函数功能的确立，包括指定函数名、函数值类型、形参及其类型函数体等，它是一个完整的、独立的函数单位
2. 函数的声明的作用是把函数的名字、函数类型及形参的类型、个数和顺序通知编译系统，以便在调用该函数时编译系统能正确识别函数并检查调用是否合法
3. 隐式声明：C语言中有几种声明的类型名可以省略。例如，**函数如果不显式地声明返回值的类型，那么它默认返回整型**；使用旧风格声明函数的形式参数时，如果省略参数的类型，那么编译器默认它们为整型。

### 2、函数的分类与调用

**从用户角度来分：**

(1) **标准函数**：即库函数，这是由系统提供的，用户不必自己定义的函数，可以直接使用它们，如printf函数、scanf函数。不同的C系统提供的库函数的数量和功能会有一些不同，但许多基本的函数是相同的。
(2) **用户自己定义的函数**：用以解决用户的专门需要.

**从函数的形式来分：**

（1）**无参函数**

（2）**有参函数**

### 3、函数的递归调用

我们把函数自身调用自身的操作，称为递归函数，递归函数一定要有结束条件，否则会产生死循环！

```c
#include <stdio.h>
//求n的阶乘
int f(int n)
{
	if(1==n){
		return 1;
	}
	return n*f(n-1);
{


//走楼梯
int step(int n)
{
	if(1==n)
		return 1;
	if(2==n)	
		return 2;
	return step(n-1)+step(n-2);
}
int main(){
	int n;
	int ret;
	scanf("%d",&n)//请输入数字的大小
	ret=f(n);
	printf("%d\n",ret);
	scanf("%d",&n);//请输入台阶数
	ret=step(n);
	printf("%d\n",ret);
	return 0;
}
```

## 六、结构体

### 1、定义

有时候需要将不同类型的数据组合为一个整体，以便于引用。例如，一名学生有学号、姓名、性别、年龄、地址等属性，如果针对学生的学号、姓名、年龄等都单独定义一个变量，那么在有多名学生时，变量就难以分清。为此，C语言提供结构体来管理不同类型的数据组合。声明一个结构体类型的一般形式为

> struct 结构体名
>
> ​			{成员表列}；

例如：

> struct student
>
> {
>
> ​		int num;char name[20];char sex;
> ​		int age;float score;char addr[30];
>
> }

先声明结构体类型，再定义变量名。例如

> struct student student1,student2

**如果结构体变量已经定义，那么只能对它的每个成员单独赋值，如student1.num=1003**。

### 2、结构体指针

一个结构体变量的指针就是该变量所占据的内存段的起始地址。可以设置一个指针变量，用它指向一个结构体变量，此时该指针变量的值是结构体变量的起始地址。指针变量也可以用来指向结构体数组中的元素，从而能够通过结构体指针快速访问结构体内的每个成员。

```c
#include <stdio.h>
//结构体指针
struct student{
	int num;
	char name[20];
	char sex;
};
int main()
{
	struct student s={1001,"wangle",'M'};
	struct student sarr[3]={1001,"lilei",'M',1005,"zhangsan",'M',1007,"lili",'F'};
	struct student *p; //定义结构体指针
	int num;
	p=&s;
	printf("%d %s %c\n",p->num,p->name,p->sex);
	p=sarr;
	printf("%d %s %c\n",(*p).num,(*p).name,(*p).sex); //方式一获取成员
	printf("%d %s %c\n",p->num,p->name,p->sex); //方式二获取成员
	printf("------------------------------\n");
	p=p+1;
	printf("%d %s %c\n",p->num,p->name,p->sex);
	return 0;
}
```

使用`(*p).num `访问成员为什么要加括号呢？原因是“ . ”成员选择的优先级高于“`*`”（即取值）运算符，所以必须加括号，通过*p 得到 sarr[0]，然后获取对应的成员。

### 3、typedef的使用

作用：简化struct变量的声明，起别名

```c
#include <stdio.h>
//结构体指针
typedef struct student{
	int num;
	char name[20];	
	char sex;
}stu,*pstu;
typedef int INTEGER;
int main()
{
	stu s={1001,"wangle",'M'};
	pstu p;
	INTEGER i=10;
	p=&s;
	printf("i=%d,p->num=%d\n",i,p->num);
	return 0;
}
```

使用 **stu 定义结构体变量和使用 struct student** 定义结构体变量是等价的；使用 INTEGER定义变量 i 和使用 int 定义变量 i 是等价的；pstu 等价于 struct student*，所以 p 是结构体指针变量。

### 4、c++的引用讲解

c++

```c++
#include <stdio.h>
void modify_num(int &b)
{
	b=b+1;
}
int main() {
	int a=10;
	modify_num(a);
	printf("after modify_num a=%d\n",a);
    return 0;
}
```

**使用了引用后，在子函数内的操作和函数外操作手法一致，这样编程效率较高，对于初学者理解也非常方便。**

c**语言比较**

```c
#include <stdio.h>
void modify_num(int *b)
{
	*b=*b+1;
}
int main() {
	int a=10;
	modify_num(&a);
	printf("after modify_num a=%d\n",a);
	return 0;
}

```

#### 另一个应用：解决c语言二级指针

c++代码

```c++
#include <stdio.h>
void modify_pointer(int* &p,int *q)
{
	p=q;
}
int main() {
	int *p=NULL;
	int i=10;
	int *q=&i;
	modify_pointer(p,q);
	printf("after modify_pointer *p=%d\n",*p);
	return 0;
}
```

c语言，需要用到二级指针

```c
#include <stdio.h>
void modify_pointer(int **p,int *q)//相对于 C++这里是 int **p;
{ 
	*p=q;
}
int main() {
	int *p=NULL;
	int i=10;
	int *q=&i;
	modify_pointer(&p,q);//相对于 C++这里是&p
	printf("after modify_pointer *p=%d\n",*p);
	return 0;
}
```

